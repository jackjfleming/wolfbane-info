<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolf's Bane Rules Display</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Using a custom font for a more thematic feel */
        body {
            font-family: 'Merriweather', serif;
            background-color: #1a1a1a; /* Dark background for TV viewing */
            color: #f0f0f0;
            overflow: hidden; /* Prevents scrollbars */
        }
        .slide {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 2rem 1rem;
            opacity: 0;
            transition: opacity 0.7s ease-in-out;
            background-color: #1a1a1a;
            overflow-y: auto; /* Allow scrolling for long descriptions */
        }
        .slide.active {
            display: flex;
            opacity: 1;
        }
        /* Custom colors for roles */
        .villager { color: #A0C5E8  ; }
        .outsider { color: #D0E2F3; }
        .minion { color: #F5CBCC; }
        .alpha-wolf { color: #EA9999; }
        .traveler { color: #FFF3CC; }


        .slide-content ul {
            list-style-type: none;
            padding-left: 0;
        }
        .slide-content li {
            margin-bottom: 1.25rem;
            font-size: 1.5rem;
            line-height: 1.6;
        }
        .ability-text {
            font-size: 1.25rem;
            line-height: 1.7;
            text-align: left;
            max-width: 65ch;
        }
        /* Styles for formatted lists within ability descriptions */
        .ability-text ul {
            list-style-type: disc;
            list-style-position: outside;
            padding-left: 1.75rem;
            margin-top: 1rem;
        }
        .ability-text li {
            font-size: 1.2rem;
            padding-left: 0.5rem;
            margin-bottom: 0.75rem;
        }

        @media (min-width: 768px) {
             .slide-content > ul > li { /* Target only the top-level list items */
                font-size: 2rem;
             }
             .ability-text {
                font-size: 1.5rem;
             }
             .ability-text li {
                font-size: 1.4rem;
             }
             .slide {
                padding: 4rem 2rem;
             }
        }
        /* Styling for the navigation controls */
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: rgba(0,0,0,0.5);
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            z-index: 100;
        }
        .control-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        .control-btn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        #progress-bar-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: rgba(255,255,255,0.2);
            z-index: 99;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background-color: #3b82f6;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body class="w-screen h-screen">

    <!-- Slides Container -->
    <main id="slides-container">

        <!-- Slide 1: Title -->
        <div class="slide active">
            <div class="m-auto text-center">
                <h1 class="text-6xl md:text-8xl font-bold mb-4">Wolf's Bane</h1>
                <p class="text-4xl md:text-6xl text-gray-300">Rule Reminders</p>
            </div>
        </div>

        <!-- Slide 2: Executions -->
        <div class="slide">
            <div class="m-auto text-left max-w-5xl slide-content">
                <h1 class="text-5xl md:text-7xl font-bold mb-12 text-center">Executions</h1>
                <ul>
                    <li>Only alive players may nominate. Dead players may be nominated.</li>
                    <li>Each player can only nominate and be nominated once per day.</li>
                    <li>Alive players can vote as many times as they want, but dead players only have one vote for the rest of the game.</li>
                    <li>The vote succeeds if votes equal or exceed half the number of alive players (rounded up).</li>
                    <li>A player is executed if they receive more votes than anyone else. No execution on a tie.</li>
                </ul>
            </div>
        </div>

        <!-- Slide 3: Death is Not the End -->
        <div class="slide">
            <div class="m-auto text-center max-w-4xl slide-content">
                <h1 class="text-5xl md:text-7xl font-bold mb-12">Death is Not the End</h1>
                <ul>
                    <li>You can (and should!) talk.</li>
                    <li>You must close your eyes at night.</li>
                    <li>You cannot nominate.</li>
                    <li>You have one vote for the rest of the game.</li>
                </ul>
            </div>
        </div>

        <!-- Slide 4: Travelers -->
        <div class="slide">
            <div class="m-auto text-left max-w-5xl slide-content">
                <h1 class="text-5xl md:text-7xl font-bold mb-12 text-center">Travelers</h1>
                <ul>
                    <li>Travelers count as alive for voting numbers, but not for win conditions or setup.</li>
                    <li>Travelers can be exiled after nominations are open.</li>
                    <li>Exiling doesn't count as a normal nomination, vote, or execution.</li>
                    <li>A majority of ALL players (alive and dead) is required for exile.</li>
                </ul>
            </div>
        </div>

        <!-- Role Slides will be injected here by JavaScript -->

    </main>

    <!-- Role Filter Controls -->
    <div class="fixed top-4 right-4 z-50">
        <select id="role-filter" class="bg-black bg-opacity-70 text-white border border-gray-600 rounded px-3 py-2 text-sm">
            <option value="all">All Roles</option>
            <option value="standard">Standard Roles</option>
            <option value="new">New Roles</option>
        </select>
    </div>

    <!-- Navigation Controls -->
    <div class="controls">
        <button id="prev-btn" class="control-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16">
                <path d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
            </svg>
        </button>
        <button id="play-pause-btn" class="control-btn">
            <!-- Pause Icon -->
            <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16">
                <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5A1.5 1.5 0 0 1 5.5 3.5zm4 0A1.5 1.5 0 0 1 11 5v6a1.5 1.5 0 0 1-3 0V5A1.5 1.5 0 0 1 9.5 3.5z"/>
            </svg>
            <!-- Play Icon (hidden by default) -->
            <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="hidden" viewBox="0 0 16 16">
                <path d="M10.804 8 5 4.633v6.734L10.804 8z"/>
            </svg>
        </button>
        <button id="next-btn" class="control-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16">
                <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
            </svg>
        </button>
    </div>

    <!-- Progress Bar -->
    <div id="progress-bar-container">
        <div id="progress-bar"></div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Data for all the roles in Trouble Brewing, now with HTML formatting and custom names
            const roles = [
                // Villager
                { name: 'Housekeeper', team: 'Villager', ability: `You start knowing that a specific Villager is in play, but not who is playing them. <ul><li>During the first night, you are woken, shown two players, and learn the character of one of them.</li><li>You learn this only once.</li></ul>` },
                { name: 'Librarian', team: 'Villager', ability: `You start knowing that a particular Outsider character is in play, but not who it is.<ul><li>During the first night, you learn that one of two players is a specific Outsider.</li><li>You learn this only once.</li><li>If you learn about the Village Idiot, you do not learn the Villager they think they are.</li></ul>` },
                { name: 'Investigator', team: 'Villager', ability: `You start knowing that a particular Minion character is in play, but not who it is.<ul><li>During the first night, you learn that one of two players is a specific Minion.</li><li>You learn this only once.</li></ul>` },
                { name: 'Chef', team: 'Villager', ability: `You know if evil players are sitting next to each other.<ul><li>On the first night, you learn the exact number of pairs of adjacent evil players.</li><li>A "pair" is two adjacent players. Three in a row is two pairs, four is three pairs, etc.</li><li>Detects evil Travelers, but only if they joined before you act.</li></ul>` },
                { name: 'Empath', team: 'Villager', ability: `Each night, you learn how many of your two alive neighbors are evil.<ul><li>You only learn the number, not which neighbor is evil.</li><li>If a neighbor is dead, your ability checks the next alive player in that direction.</li><li>You act after the Alpha Wolf, so your information is accurate as of the morning.</li></ul>` },
                { name: 'Seer', team: 'Villager', ability: `You can detect the Alpha Wolf, but a good player may seem like an Alpha Wolf to you.<ul><li>Each night, choose two players. You learn if at least one is an Alpha Wolf.</li><li>You do not learn *which* one is the Alpha Wolf, just that an Alpha Wolf is present.</li><li>A "Red Herring" good player will always register as an Alpha Wolf to you. You don't know who this is.</li><li>You may choose any two players: alive, dead, or even yourself.</li></ul>` },
                { name: 'Gravedigger', team: 'Villager', ability: `You learn the character of players who are executed.<ul><li>You only learn about players killed by execution, not by other means.</li><li>You wake each night *except the first*.</li><li>If nobody is executed, you learn nothing.</li><li>If the Village Idiot is executed, you are shown the Village Idiot token.</li></ul>` },
                { name: 'Bodyguard', team: 'Villager', ability: `You protect other players from the Alpha Wolf.<ul><li>Each night except the first, you may choose one player (not yourself) to protect.</li><li>If the Alpha Wolf attacks your chosen player, that player does not die.</li><li>The Alpha Wolf's attack is simply cancelled for the night; they don't get a re-do.</li><li>This does not protect from execution.</li></ul>` },
                { name: 'Ravenkeeper', team: 'Villager', ability: `If you die at night, you get to learn one player's character.<ul><li>You are woken on the night that you die to make your choice.</li><li>You may choose any player, alive or dead.</li></ul>` },
                { name: 'New in Town', team: 'Villager', ability: `Your nomination can expose and execute a fellow Villager.<ul><li>If a Villager nominates you, they are executed immediately.</li><li>The nomination process ends for the day.</li><li>If an Outsider, Minion, or Alpha Wolf nominates you, nothing happens.</li><li>Your ability is lost after you are nominated for the first time, regardless of the outcome.</li></ul>` },
                { name: 'Hunter', team: 'Villager', ability: `Once per game, you may be able to kill the Alpha Wolf.<ul><li>During the day, you can publicly declare you are using your ability on a player.</li><li>If you choose the Alpha Wolf, they die immediately. Otherwise, nothing happens.</li><li>The dead player's identity is not revealed.</li><li>Using your ability while poisoned or drunk wastes it.</li></ul>` },
                { name: 'Soldier', team: 'Villager', ability: `You are safe from the Alpha Wolf.<ul><li>You cannot be killed by the Alpha Wolf's nightly attack.</li><li>If the Alpha Wolf targets you, nobody dies that night.</li><li>You can still be executed.</li></ul>` },
                { name: 'Mayor', team: 'Villager', ability: `You can bring about a peaceful victory for the good team.<ul><li>If you are attacked at night, the Storyteller may choose for another player to die instead.</li><li>If there are 3 players left alive and no execution happens, the game ends and good wins.</li><li>Travelers count as players for your win condition and must be exiled first.</li></ul>` },
                // Outsiders
                { name: 'Butler', team: 'Outsider', ability: `You must vote when your chosen Master votes.<ul><li>Each night, you choose a player to be your Master for the next day.</li><li>You may only have your hand up to vote if your Master's hand is also up.</li><li>You are responsible for following this rule, not the Storyteller.</li><li>You can vote freely during exiles. You are never forced to vote.</li></ul>` },
                { name: 'Village Idiot', team: 'Outsider', ability: `You think you are a Villager, but you are not.<ul><li>You do not know you are the Village Idiot. You have a Villager token.</li><li>Your "ability" doesn't work.</li><li>The Storyteller pretends your ability works, waking you at night as normal and possibly giving you false information.</li></ul>` },
                { name: 'Recluse', team: 'Outsider', ability: `You are good, but you might appear to be evil.<ul><li>When your alignment or character is checked, the Storyteller decides if you register as good, evil, or even a specific evil character.</li><li>This can change from one moment to the next.</li><li>Registering as a character does not grant you their ability.</li></ul>` },
                { name: 'Saint', team: 'Outsider', ability: `Your execution means victory for the evil team.<ul><li>If you die by execution, the game ends immediately and evil wins.</li><li>If you die by any other means (like an Alpha Wolf attack), the game continues.</li></ul>` },
                // Minions
                { name: 'Poisoner', team: 'Minion', ability: `You secretly disrupt other players' abilities.<ul><li>Each night, choose a player. They are poisoned for that night and the entire next day.</li><li>A poisoned player's ability fails, but the Storyteller will pretend it works, possibly giving them false information.</li><li>Using a "once per game" ability while poisoned wastes it.</li></ul>` },
                { name: 'Spy', team: 'Minion', ability: `You see everything, and you can hide in plain sight.<ul><li>Each night, you get to look at the Grimoire.</li><li>When other players' abilities check you, you might register as good, or as a specific Villager or Outsider.</li><li>The Storyteller decides how you register.</li><li>Registering as a character does not grant you their ability.</li></ul>` },
                { name: 'Successor', team: 'Minion', ability: `When the Alpha Wolf dies, you may become the new Alpha Wolf.<ul><li>If the Alpha Wolf dies and 5 or more players are alive, you secretly become the Alpha Wolf.</li><li>Travelers do not count towards the 5+ players.</li><li>If the Alpha Wolf kills themself at night with 5+ players alive, you *must* become the new Alpha Wolf.</li></ul>` },
                { name: 'Baron', team: 'Minion', ability: `You make the game harder for the good team from the start.<ul><li>During setup, two Outsiders are added to the game.</li><li>These Outsiders replace two Villager.</li><li>This change is permanent, even if you die.</li></ul>` },
                // Alpha Wolf
                { name: 'Alpha Wolf', team: 'Alpha Wolf', ability: `You kill each night, but can sacrifice yourself to pass on the curse.<ul><li>Each night except the first, choose a player. They die.</li><li>You know your Minions and three not-in-play good characters to bluff as.</li><li>If you die, good wins... unless you kill yourself at night.</li><li>If you kill yourself, an alive Minion becomes the new Alpha Wolf. The new Alpha Wolf does not act on the night they are promoted.</li></ul>` }
                ,
                // Additional Roles
                { name: 'Artist', team: 'Townsfolk', ability: `Once per game, you may privately ask the Storyteller any "yes" or "no" question.<ul><li>The Storyteller must answer honestly with "Yes," "No," or "I don't know."</li><li>It is your responsibility to initiate this conversation privately.</li></ul>` },
                { name: 'Professor', team: 'Townsfolk', ability: `Once per game, you can choose a dead player to resurrect.<ul><li>If you choose a Townsfolk, they become alive again and regain their ability (even "once per game" abilities).</li><li>If you choose an Outsider, Minion, or Alpha Wolf, nothing happens, but your ability is used up.</li><li>Resurrected players with "first night only" abilities get to use them again immediately.</li></ul>` },
                { name: 'Klutz', team: 'Outsider', ability: `When you die, you must publicly choose a player.<ul><li>If you choose an evil player, the good team loses immediately.</li><li>If you choose a good player, nothing happens.</li><li>You must make this choice shortly after you die. It is your responsibility, not the Storyteller's.</li></ul>` },
                { name: 'Evil Twin', team: 'Minion', ability: `You are paired with a good player (your "Good Twin").<ul><li>On the first night, you and your Good Twin see each other.</li><li>If your Good Twin is executed, the evil team wins.</li><li>The good team cannot win while you are both alive, even if the Alpha Wolf is dead.</li><li>If you are executed, your link is broken and this ability ends.</li></ul>` },
                // Travelers
                { name: 'Butcher', team: 'Traveler', ability: `Each day, if an execution occurs, you may nominate a second player for execution.<ul><li>This happens after the first execution is resolved.</li><li>This second nomination proceeds like a normal one and requires its own vote.</li><li>You can use this ability even if you already nominated today.</li></ul>` },
                { name: 'Gangster', team: 'Traveler', ability: `Each day, you may conspire with one of your alive neighbors to kill your other alive neighbor.<ul><li>You and one neighbor must both agree to kill the other neighbor.</li><li>The Storyteller must witness this agreement. The target dies immediately.</li><li>You can only use this ability once per day.</li><li>If both neighbors want to conspire with you, you decide who dies.</li></ul>` },
                { name: 'Scapegoat', team: 'Traveler', ability: `The Storyteller may choose for you to die in place of another player of your alignment who is executed.<ul><li>This can only happen due to an execution.</li><li>Your death counts as the execution for the day.</li><li>Players do not learn your alignment when you die.</li></ul>` },
                { name: 'Gunslinger', team: 'Traveler', ability: `Each day, immediately after the first vote tally, you may publicly choose a player who just voted. That player dies.<ul><li>You can only use this ability once per day.</li><li>It is your responsibility to speak up and use this ability.</li><li>This cannot be used on a vote to exile a Traveler.</li></ul>` },
                { name: 'Beggar', team: 'Traveler', ability: `You cannot vote unless a dead player gives you their vote token.<ul><li>When a dead player gives you their token, you learn their alignment (good/evil).</li><li>Each vote you cast uses up one token.</li><li>You can still nominate and vote on exiles freely.</li><li>You cannot be poisoned or made drunk.</li></ul>` },
                { name: 'Bureaucrat', team: 'Traveler', ability: `Each day, you secretly choose a player. For the rest of the day, their vote counts as three votes.<ul><li>All players will know who you chose when votes are counted.</li><li>This ability ends if you die or are exiled.</li><li>This does not affect votes for exiling other Travelers.</li></ul>` },
                { name: 'Thief', team: 'Traveler', ability: `Each day, you secretly choose a player. For the rest of the day, their vote counts as negative one.<ul><li>All players will know who you chose when votes are counted.</li><li>This ability ends if you die or are exiled.</li><li>This does not affect votes for exiling other Travelers.</li></ul>` }
 

            ];

            // Define which roles are "new"
            const newRoles = ['Artist', 'Professor', 'Gangster', 'Butcher', 'Evil Twin', 'Klutz'];

            const slidesContainer = document.getElementById('slides-container');
            const teamColorMap = {
                'Villager': 'villager',
                'Outsider': 'outsider',
                'Minion': 'minion',
                'Alpha Wolf': 'alpha-wolf',
                'Traveler': 'traveler'
            };

            // Map each role name to its corresponding image path
            const roleImageMap = {
                'Housekeeper': 'images/Housekeeper.svg',
                'Librarian': 'images/Librarian.svg',
                'Investigator': 'images/Investigator.svg',
                'Chef': 'images/Chef.svg',
                'Empath': 'images/Empath.svg',
                'Seer': 'images/Seer.svg',
                'Gravedigger': 'images/Gravedigger.svg',
                'Bodyguard': 'images/Bodyguard.svg',
                'Ravenkeeper': 'images/Ravenkeeper.svg',
                'New in Town': 'images/New in Town.svg',
                'Hunter': 'images/Hunter.svg',
                'Soldier': 'images/Soldier.svg',
                'Mayor': 'images/Mayor.svg',
                'Butler': 'images/Butler.svg',
                'Village Idiot': 'images/Village Idiot.svg',
                'Recluse': 'images/Recluse.svg',
                'Saint': 'images/Saint.svg',
                'Poisoner': 'images/Poisoner.svg',
                'Spy': 'images/artist.svg', // fallback image (no Spy.svg found)
                'Successor': 'images/Successor.svg',
                'Baron': 'images/Baron.svg',
                'Alpha Wolf': 'images/Fenrir.svg', // using Fenrir art for Alpha Wolf
                // New roles
                'Klutz': 'images/Klutz.svg',
                'Professor': 'images/professor.svg',
                'Artist': 'images/Artist.svg',
                'Evil Twin': 'images/Evil Twin.svg',
                'Butcher': 'images/Butcher.svg',
                'Gangster': 'images/Gangster.svg',
                'Scapegoat': 'images/Scapegoat.svg',
                'Gunslinger': 'images/Gunslinger.svg',
                'Beggar': 'images/Beggar.svg',
                'Bureaucrat': 'images/Bureaucrat.svg',
                'Thief': 'images/Thief.svg'
            };

            // --- Icon Coloring Helpers ---
            async function fetchAndColorizeSVG(url) {
                const res = await fetch(url);
                const text = await res.text();
                // Force all fills and strokes to use currentColor so we can color via CSS
                const colored = text
                    .replace(/fill="[^"]*"/g, 'fill="currentColor"')
                    .replace(/stroke="[^"]*"/g, 'stroke="currentColor"');
                const parser = new DOMParser();
                const doc = parser.parseFromString(colored, 'image/svg+xml');
                const svg = doc.documentElement;
                svg.setAttribute('class', 'mx-auto mb-4 w-32 h-32 md:w-48 md:h-48 object-contain');
                svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                svg.setAttribute('aria-hidden', 'true');
                return svg;
            }
            function injectIcon(container, src) {
                fetchAndColorizeSVG(src).then(svg => {
                    container.replaceWith(svg);
                }).catch(() => {
                    const img = document.createElement('img');
                    img.src = src;
                    img.alt = '';
                    img.className = 'mx-auto mb-4 w-32 h-32 md:w-48 md:h-48 object-contain';
                    container.replaceWith(img);
                });
            }

            function renderIcon(placeholderEl, src, teamClass) {
                // If opened from file:/// protocol, Chrome may block CSS mask URLs — use <img> fallback
                const isFileProtocol = window.location.protocol === 'file:';
                if (isFileProtocol) {
                    const img = document.createElement('img');
                    img.src = src;
                    img.alt = '';
                    img.className = 'mx-auto mb-4 w-32 h-32 md:w-48 md:h-48 object-contain';
                    // Make it visible on dark background when opened via file://
                    img.style.filter = 'invert(1) brightness(1.2)';
                    placeholderEl.replaceWith(img);
                } else {
                    const maskDiv = document.createElement('div');
                    maskDiv.className = `mx-auto mb-4 w-32 h-32 md:w-48 md:h-48 ${teamClass}`;
                    maskDiv.style.backgroundColor = 'currentColor';
                    maskDiv.style.webkitMaskImage = `url('${src}')`;
                    maskDiv.style.webkitMaskRepeat = 'no-repeat';
                    maskDiv.style.webkitMaskPosition = 'center';
                    maskDiv.style.webkitMaskSize = 'contain';
                    maskDiv.style.maskImage = `url('${src}')`;
                    maskDiv.style.maskRepeat = 'no-repeat';
                    maskDiv.style.maskPosition = 'center';
                    maskDiv.style.maskSize = 'contain';
                    placeholderEl.replaceWith(maskDiv);
                }
            }

            // This function creates a slide for each role and adds it to the page
            roles.forEach(role => {
                const slideEl = document.createElement('div');
                slideEl.className = 'slide';
                // Add data attributes for filtering
                slideEl.dataset.roleName = role.name;
                slideEl.dataset.roleType = newRoles.includes(role.name) ? 'new' : 'standard';
                const iconSrc = roleImageMap[role.name] || 'images/artist.svg';
                // Use a div for ability-text to allow for block elements like <ul>
                slideEl.innerHTML = `
                    <div class="m-auto text-center max-w-5xl slide-content">
                        <div><span class="role-icon-placeholder"></span></div>
                        <h1 class="text-4xl md:text-6xl font-bold mb-4 ${teamColorMap[role.team]}">${role.name}</h1>
                        <p class="text-2xl md:text-4xl mb-6 text-gray-400">${role.team}</p>
                        <div class="ability-text">${role.ability}</div>
                    </div>
                `;
                slidesContainer.appendChild(slideEl);
                const placeholder = slideEl.querySelector('.role-icon-placeholder');
                renderIcon(placeholder, iconSrc, teamColorMap[role.team]);
            });

            // --- Role Filtering Logic ---
            const roleFilter = document.getElementById('role-filter');
            let allSlides = document.querySelectorAll('.slide');
            let visibleSlides = Array.from(allSlides);

            function filterSlides(filterType) {
                // Hide all slides first
                allSlides.forEach(slide => {
                    slide.style.display = 'none';
                });

                // Show slides based on filter
                if (filterType === 'all') {
                    visibleSlides = Array.from(allSlides);
                } else if (filterType === 'new') {
                    visibleSlides = Array.from(allSlides).filter(slide =>
                        slide.dataset.roleType === 'new'
                    );
                } else if (filterType === 'standard') {
                    visibleSlides = Array.from(allSlides).filter(slide =>
                        slide.dataset.roleType === 'standard'
                    );
                }

                // Show filtered slides
                visibleSlides.forEach(slide => {
                    slide.style.display = 'flex';
                });

                // Reset to first slide of filtered set
                currentSlide = 0;
                if (visibleSlides.length > 0) {
                    showSlide(0);
                }
                resetTimer();
            }

            roleFilter.addEventListener('change', (e) => {
                filterSlides(e.target.value);
            });

            // --- Slideshow Logic ---
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const progressBar = document.getElementById('progress-bar');

            let currentSlide = 0;
            let isPlaying = true;
            const slideInterval = 15000; // 15 seconds per slide
            let slideTimer;
            let progressTimer;

            // Function to display a specific slide
            function showSlide(index) {
                // Reset scroll position of the old slide
                if (visibleSlides[currentSlide]) {
                    visibleSlides[currentSlide].scrollTop = 0;
                }
                visibleSlides.forEach((slide, i) => {
                    slide.classList.remove('active');
                    if (i === index) {
                        slide.classList.add('active');
                    }
                });
            }

            // Function to go to the next slide
            function nextSlide() {
                if (visibleSlides.length === 0) return;
                currentSlide = (currentSlide + 1) % visibleSlides.length;
                showSlide(currentSlide);
                resetTimer();
            }

            // Function to go to the previous slide
            function prevSlide() {
                if (visibleSlides.length === 0) return;
                currentSlide = (currentSlide - 1 + visibleSlides.length) % visibleSlides.length;
                showSlide(currentSlide);
                resetTimer();
            }

            // This function animates the progress bar at the bottom
            function updateProgressBar() {
                let startTime = Date.now();
                clearInterval(progressTimer);

                if(isPlaying) {
                    progressTimer = setInterval(() => {
                        const elapsedTime = Date.now() - startTime;
                        const width = (elapsedTime / slideInterval) * 100;
                        progressBar.style.width = `${width}%`;
                        if (width >= 100) {
                            clearInterval(progressTimer);
                        }
                    }, 100);
                }
            }

            // This function resets the autoplay timer and progress bar
            function resetTimer() {
                clearTimeout(slideTimer);
                clearInterval(progressTimer);
                progressBar.style.transition = 'none'; // Disable transition for instant reset
                progressBar.style.width = '0%';
                progressBar.offsetHeight; // Force browser to repaint, making the reset instant
                progressBar.style.transition = 'width 0.1s linear'; // Re-enable for the next animation

                if (isPlaying) {
                    slideTimer = setTimeout(nextSlide, slideInterval);
                    updateProgressBar();
                }
            }

            // Function to toggle between play and pause states
            function togglePlayPause() {
                isPlaying = !isPlaying;
                if (isPlaying) {
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                    resetTimer();
                } else {
                    pauseIcon.classList.add('hidden');
                    playIcon.classList.remove('hidden');
                    clearTimeout(slideTimer);
                    clearInterval(progressTimer);
                }
            }

            // --- Event Listeners ---
            nextBtn.addEventListener('click', nextSlide);
            prevBtn.addEventListener('click', prevSlide);
            playPauseBtn.addEventListener('click', togglePlayPause);

            // Allow keyboard navigation with arrow keys and spacebar
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowRight') {
                    nextSlide();
                } else if (e.key === 'ArrowLeft') {
                    prevSlide();
                } else if (e.key === ' ') { // Spacebar to play/pause
                    e.preventDefault(); // Prevents the page from scrolling on spacebar press
                    togglePlayPause();
                }
            });

            // Initial setup when the page loads
            showSlide(currentSlide);
            resetTimer();
        });
    </script>
</body>
</html>
