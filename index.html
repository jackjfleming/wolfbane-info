<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolf's Bane Rules Display</title>

    <!-- Favicons -->
    <link rel="icon" type="image/x-icon" href="icons/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Using a custom font for a more thematic feel */
        body {
            font-family: 'Merriweather', serif;
            background-color: #1a1a1a; /* Dark background for TV viewing */
            color: #f0f0f0;
            overflow: hidden; /* Prevents scrollbars */
        }
        .slide {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 2rem 1rem;
            opacity: 0;
            transition: opacity 0.7s ease-in-out;
            background-color: #1a1a1a;
            overflow-y: auto; /* Allow scrolling for long descriptions */
        }
        .slide.active {
            display: flex;
            opacity: 1;
        }
        /* Custom colors for roles */
        .villager { color: #A0C5E8  ; }
        .outsider { color: #D0E2F3; }
        .minion { color: #F5CBCC; }
        .alpha-wolf { color: #EA9999; }
        .traveler { color: #FFF3CC; }


        .slide-content ul {
            list-style-type: none;
            padding-left: 0;
        }
        .slide-content li {
            margin-bottom: 1.25rem;
            font-size: 1.5rem;
            line-height: 1.6;
        }
        .ability-text {
            font-size: 1.25rem;
            line-height: 1.7;
            text-align: left;
            max-width: 65ch;
        }
        /* Styles for formatted lists within ability descriptions */
        .ability-text ul {
            list-style-type: disc;
            list-style-position: outside;
            padding-left: 1.75rem;
            margin-top: 1rem;
        }
        .ability-text li {
            font-size: 1.2rem;
            padding-left: 0.5rem;
            margin-bottom: 0.75rem;
        }

        @media (min-width: 768px) {
             .slide-content > ul > li { /* Target only the top-level list items */
                font-size: 2rem;
             }
             .ability-text {
                font-size: 1.5rem;
             }
             .ability-text li {
                font-size: 1.4rem;
             }
             .slide {
                padding: 4rem 2rem;
             }
        }
        /* Styling for the navigation controls */
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: rgba(0,0,0,0.5);
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            z-index: 100;
        }
        .control-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        .control-btn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        #progress-bar-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: rgba(255,255,255,0.2);
            z-index: 99;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background-color: #3b82f6;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body class="w-screen h-screen">

    <!-- Slides Container -->
    <main id="slides-container">

        <!-- Slide 1: Title -->
        <div class="slide active">
            <div class="m-auto text-center">
                <h1 class="text-6xl md:text-8xl font-bold mb-4">Wolf's Bane</h1>
                <p class="text-4xl md:text-6xl text-gray-300">Rule Reminders</p>
            </div>
        </div>

        <!-- Slide 2: Executions -->
        <div class="slide">
            <div class="m-auto text-left max-w-5xl slide-content">
                <h1 class="text-5xl md:text-7xl font-bold mb-12 text-center">Executions</h1>
                <ul>
                    <li>Only alive players may nominate. Dead players may be nominated.</li>
                    <li>Each player can only nominate and be nominated once per day.</li>
                    <li>Alive players can vote as many times as they want, but dead players only have one vote for the rest of the game.</li>
                    <li>The vote succeeds if votes equal or exceed half the number of alive players (rounded up).</li>
                    <li>A player is executed if they receive more votes than anyone else. No execution on a tie.</li>
                </ul>
            </div>
        </div>

        <!-- Slide 3: Death is Not the End -->
        <div class="slide">
            <div class="m-auto text-center max-w-4xl slide-content">
                <h1 class="text-5xl md:text-7xl font-bold mb-12">Death is Not the End</h1>
                <ul>
                    <li>You can (and should!) talk.</li>
                    <li>You must close your eyes at night.</li>
                    <li>You cannot nominate.</li>
                    <li>You have one vote for the rest of the game.</li>
                </ul>
            </div>
        </div>

        <!-- Slide 4: Travelers -->
        <div class="slide">
            <div class="m-auto text-left max-w-5xl slide-content">
                <h1 class="text-5xl md:text-7xl font-bold mb-12 text-center">Travelers</h1>
                <ul>
                    <li>Travelers count as alive for voting numbers, but not for win conditions or setup.</li>
                    <li>Travelers can be exiled after nominations are open.</li>
                    <li>Exiling doesn't count as a normal nomination, vote, or execution.</li>
                    <li>A majority of ALL players (alive and dead) is required for exile.</li>
                </ul>
            </div>
        </div>

        <!-- Role Slides will be injected here by JavaScript -->

    </main>

    <!-- Role Filter Controls -->
    <div class="fixed top-4 right-4 z-50">
        <select id="role-filter" class="bg-black bg-opacity-70 text-white border border-gray-600 rounded px-3 py-2 text-sm">
            <option value="all">All Roles</option>
            <option value="standard">Standard Roles</option>
            <option value="new">New Roles</option>
        </select>
    </div>

    <!-- Navigation Controls -->
    <div class="controls">
        <button id="prev-btn" class="control-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16">
                <path d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
            </svg>
        </button>
        <button id="play-pause-btn" class="control-btn">
            <!-- Pause Icon -->
            <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16">
                <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5A1.5 1.5 0 0 1 5.5 3.5zm4 0A1.5 1.5 0 0 1 11 5v6a1.5 1.5 0 0 1-3 0V5A1.5 1.5 0 0 1 9.5 3.5z"/>
            </svg>
            <!-- Play Icon (hidden by default) -->
            <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="hidden" viewBox="0 0 16 16">
                <path d="M10.804 8 5 4.633v6.734L10.804 8z"/>
            </svg>
        </button>
        <button id="next-btn" class="control-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16">
                <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
            </svg>
        </button>
    </div>

    <!-- Progress Bar -->
    <div id="progress-bar-container">
        <div id="progress-bar"></div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            // Load roles data from JSON file
            let rolesData = {};
            let roles = [];

            try {
                const response = await fetch('roles.json');
                rolesData = await response.json();

                // Convert JSON structure to flat array for compatibility
                roles = [
                    ...rolesData.townsfolk.map(role => ({ ...role, team: 'Townsfolk' })),
                    ...rolesData.outsiders.map(role => ({ ...role, team: 'Outsider' })),
                    ...rolesData.minions.map(role => ({ ...role, team: 'Minion' })),
                    ...rolesData.demons.map(role => ({ ...role, team: 'Demon' })),
                    ...rolesData.travelers.map(role => ({ ...role, team: 'Traveler' }))
                ];
                console.log('Loaded', roles.length, 'roles from JSON');
            } catch (error) {
                console.error('Failed to load roles.json:', error);
                // Fallback to hardcoded data if JSON fails to load (with original detailed abilities)
                roles = [
                    // Townsfolk
                    { name: 'Housekeeper', team: 'Townsfolk', ability: `You start knowing that a specific Townsfolk is in play, but not who is playing them. <ul><li>During the first night, you are woken, shown two players, and learn the character of one of them.</li><li>You learn this only once.</li></ul>`, tipsAndTricks: ['The Housekeeper is deceptively powerful. Even though you don\'t gain information on the evil players, you can confirm the identity of a good player.', 'If you share your information on the first day, and speak up quickly, the good team has some solid information to begin with.'], bluffingAs: ['You would wake on the first night and be shown two players and a character token.', 'Nobody suspects the Housekeeper! Since you don\'t seem like much of a threat, the Housekeeper is a great bluff.'] },
                    { name: 'Librarian', team: 'Townsfolk', ability: `You start knowing that a particular Outsider character is in play, but not who it is.<ul><li>During the first night, you learn that one of two players is a specific Outsider.</li><li>You learn this only once.</li><li>If you learn about the Village Idiot, you do not learn the Townsfolk they think they are.</li></ul>`, tipsAndTricks: ['The Librarian is one of the most useful characters to the good team, and one of the most dangerous to the evil team.', 'If there are no Outsiders in play, or only 1 Outsider in play, the Storyteller will show you the same player twice.'], bluffingAs: ['You would wake on the first night and be shown two players and an Outsider token.', 'The Librarian is a fantastic bluff. Since you get such good information, the evil team will often want to kill you quickly.'] },
                    { name: 'Investigator', team: 'Townsfolk', ability: `You start knowing that a particular Minion character is in play, but not who it is.<ul><li>During the first night, you learn that one of two players is a specific Minion.</li><li>You learn this only once.</li></ul>`, tipsAndTricks: ['The Investigator is one of the most powerful good characters in the game.', 'If you learn that one of two players is the Poisoner, and one of those players dies at night, you can be almost certain that the other player is the Poisoner.'], bluffingAs: ['You would wake on the first night and be shown two players and a Minion token.', 'The Investigator is a great character to bluff as, particularly if you are a Minion.'] },
                    { name: 'Chef', team: 'Townsfolk', ability: `You know if evil players are sitting next to each other.<ul><li>On the first night, you learn the exact number of pairs of adjacent evil players.</li><li>A "pair" is two adjacent players. Three in a row is two pairs, four is three pairs, etc.</li><li>Detects evil Travelers, but only if they joined before you act.</li></ul>`, tipsAndTricks: ['Your information is most useful on the first day, and becomes less useful as players die and the seating order becomes less relevant.', 'If you learn that there are 0 pairs of evil players, then you know that no evil players are sitting next to each other.'], bluffingAs: ['You would learn a number on the first night representing pairs of adjacent evil players.', 'The Chef is a relatively easy character to bluff as, since you only have one piece of information to give.'] },
                    { name: 'Empath', team: 'Townsfolk', ability: `Each night, you learn how many of your two alive neighbors are evil.<ul><li>You only learn the number, not which neighbor is evil.</li><li>If a neighbor is dead, your ability checks the next alive player in that direction.</li><li>You act after the Alpha Wolf, so your information is accurate as of the morning.</li></ul>`, tipsAndTricks: ['Your information is incredibly useful. Each night, you learn whether 0, 1, or 2 of your living neighbors are evil.', 'If one of your neighbors dies, your ability will check the next alive player in that direction.'], bluffingAs: ['You would wake each night and learn a number (0, 1, or 2) representing evil neighbors.', 'The Empath is a powerful character, so bluffing as the Empath will make you a target for the Demon.'] },
                    { name: 'Seer', team: 'Townsfolk', ability: `You can detect the Alpha Wolf, but a good player may seem like an Alpha Wolf to you.<ul><li>Each night, choose two players. You learn if at least one is an Alpha Wolf.</li><li>You do not learn *which* one is the Alpha Wolf, just that an Alpha Wolf is present.</li><li>A "Red Herring" good player will always register as an Alpha Wolf to you. You don't know who this is.</li><li>You may choose any two players: alive, dead, or even yourself.</li></ul>`, tipsAndTricks: ['Each night, choose two players. You learn if at least one is a Demon.', 'There is always exactly one player who will register as a Demon to you, even though they are good.'], bluffingAs: ['You would wake each night and choose two players, then learn yes or no.', 'The Seer is a great character to bluff as. You can give information that confirms your fellow evil players as good.'] },
                    { name: 'Butler', team: 'Outsider', ability: `You must vote when your chosen Master votes.<ul><li>Each night, you choose a player to be your Master for the next day.</li><li>You may only have your hand up to vote if your Master's hand is also up.</li><li>You are responsible for following this rule, not the Storyteller.</li><li>You can vote freely during exiles. You are never forced to vote.</li></ul>`, tipsAndTricks: ['The player who you choose as your "Master" is very important. Your vote still counts as much as a normal vote.', 'If you tell your Master that you have selected them, they will often vote under the assumption that you will be voting with them.'], bluffingAs: ['You would wake each night, including the first night, and select a player.', 'Nobody suspects the Butler! Since you don\'t seem like much of a threat, the Butler is a great bluff.'] },
                    { name: 'Saint', team: 'Outsider', ability: `Your execution means victory for the evil team.<ul><li>If you die by execution, the game ends immediately and evil wins.</li><li>If you die by any other means (like an Alpha Wolf attack), the game continues.</li></ul>`, tipsAndTricks: ['Stay alive! If you are executed, evil wins immediately.', 'You may want to claim to be the Saint publicly, so that good players will not vote for you.'], bluffingAs: ['The Saint never wakes at night and has no ability to use during the day.', 'Bluffing as the Saint can be very effective, since good players will be reluctant to execute you.'] },
                    { name: 'Poisoner', team: 'Minion', ability: `You secretly disrupt other players' abilities.<ul><li>Each night, choose a player. They are poisoned for that night and the entire next day.</li><li>A poisoned player's ability fails, but the Storyteller will pretend it works, possibly giving them false information.</li><li>Using a "once per game" ability while poisoned wastes it.</li></ul>`, tipsAndTricks: ['Each night, choose a player. They are poisoned for that night and the entire next day.', 'Poison the most dangerous good players. Characters like the Empath, Seer, and Housekeeper are great targets.'], bluffingAs: ['You would wake each night and choose a player to poison.', 'The Poisoner is a difficult character to bluff as, since you don\'t get any information.'] },
                    { name: 'Alpha Wolf', team: 'Demon', ability: `You kill each night, but can sacrifice yourself to pass on the curse.<ul><li>Each night except the first, choose a player. They die.</li><li>You know your Minions and three not-in-play good characters to bluff as.</li><li>If you die, good wins... unless you kill yourself at night.</li><li>If you kill yourself, an alive Minion becomes the new Alpha Wolf. The new Alpha Wolf does not act on the night they are promoted.</li></ul>`, tipsAndTricks: ['Each night except the first, choose a player. They die.', 'You know your Minions and three not-in-play good characters to bluff as.'], bluffingAs: ['You would wake each night except the first and choose a player to kill.', 'As the Alpha Wolf, you want to stay alive as long as possible while eliminating threats to your team.'] }
                ];
                console.log('Using fallback data with', roles.length, 'roles');
            }

            // Function to get a random tip or bluffing entry for a role
            function getRandomTip(role) {
                const allTips = [];

                // Add tips and tricks
                if (role.tipsAndTricks && role.tipsAndTricks.length > 0) {
                    allTips.push(...role.tipsAndTricks.map(tip => ({ type: 'tip', content: tip })));
                }

                // Add bluffing entries
                if (role.bluffingAs && role.bluffingAs.length > 0) {
                    allTips.push(...role.bluffingAs.map(bluff => ({ type: 'bluff', content: bluff })));
                }

                // Return random tip or fallback
                if (allTips.length > 0) {
                    const randomTip = allTips[Math.floor(Math.random() * allTips.length)];
                    const prefix = randomTip.type === 'tip' ? '<strong>Tip:</strong> ' : '<strong>Bluffing:</strong> ';
                    return prefix + randomTip.content;
                } else {
                    return role.summary || 'No additional information available.';
                }
            }

            // Function to create ability text with original detailed summary and random tip
            function createAbilityText(role) {
                // Use the original detailed ability description if available, otherwise use summary
                const detailedAbility = role.ability || role.summary || 'No summary available.';
                const randomTip = getRandomTip(role);

                return `
                    <div class="mb-4">
                        <div class="text-lg md:text-xl mb-4">${detailedAbility}</div>
                        <div class="text-base md:text-lg text-gray-300 italic border-t border-gray-600 pt-3 mt-3">${randomTip}</div>
                    </div>
                `;
            }

            console.log('About to process', roles.length, 'roles');

            // Define which roles are "new"
            const newRoles = ['Artist', 'Professor', 'Gangster', 'Butcher', 'Evil Twin', 'Klutz'];

            const slidesContainer = document.getElementById('slides-container');
            const teamColorMap = {
                'Townsfolk': 'villager',
                'Villager': 'villager', // Legacy support
                'Outsider': 'outsider',
                'Minion': 'minion',
                'Demon': 'alpha-wolf',
                'Alpha Wolf': 'alpha-wolf', // Legacy support
                'Traveler': 'traveler'
            };

            // Map each role name to its corresponding image path
            const roleImageMap = {
                'Housekeeper': 'images/Housekeeper.svg',
                'Librarian': 'images/Librarian.svg',
                'Investigator': 'images/Investigator.svg',
                'Chef': 'images/Chef.svg',
                'Empath': 'images/Empath.svg',
                'Seer': 'images/Seer.svg',
                'Gravedigger': 'images/Gravedigger.svg',
                'Bodyguard': 'images/Bodyguard.svg',
                'Ravenkeeper': 'images/Ravenkeeper.svg',
                'New in Town': 'images/New in Town.svg',
                'Hunter': 'images/Hunter.svg',
                'Soldier': 'images/Soldier.svg',
                'Mayor': 'images/Mayor.svg',
                'Butler': 'images/Butler.svg',
                'Village Idiot': 'images/Village Idiot.svg',
                'Recluse': 'images/Recluse.svg',
                'Saint': 'images/Saint.svg',
                'Poisoner': 'images/Poisoner.svg',
                'Spy': 'images/Spy.svg',
                'Successor': 'images/Successor.svg',
                'Baron': 'images/Baron.svg',
                'Alpha Wolf': 'images/Fenrir.svg', // using Fenrir art for Alpha Wolf
                // New roles
                'Klutz': 'images/Klutz.svg',
                'Professor': 'images/Professor.svg',
                'Artist': 'images/Artist.svg',
                'Evil Twin': 'images/Evil Twin.svg',
                'Butcher': 'images/Butcher.svg',
                'Gangster': 'images/Gangster.svg',
                'Scapegoat': 'images/Scapegoat.svg',
                'Gunslinger': 'images/Gunslinger.svg',
                'Beggar': 'images/Beggar.svg',
                'Bureaucrat': 'images/Bureaucrat.svg',
                'Thief': 'images/Thief.svg'
            };

            // --- Icon Coloring Helpers ---
            async function fetchAndColorizeSVG(url) {
                const res = await fetch(url);
                const text = await res.text();
                // Force all fills and strokes to use currentColor so we can color via CSS
                const colored = text
                    .replace(/fill="[^"]*"/g, 'fill="currentColor"')
                    .replace(/stroke="[^"]*"/g, 'stroke="currentColor"');
                const parser = new DOMParser();
                const doc = parser.parseFromString(colored, 'image/svg+xml');
                const svg = doc.documentElement;
                svg.setAttribute('class', 'mx-auto mb-3 w-24 h-24 md:w-32 md:h-32 object-contain');
                svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                svg.setAttribute('aria-hidden', 'true');
                return svg;
            }
            function injectIcon(container, src) {
                fetchAndColorizeSVG(src).then(svg => {
                    container.replaceWith(svg);
                }).catch(() => {
                    const img = document.createElement('img');
                    img.src = src;
                    img.alt = '';
                    img.className = 'mx-auto mb-3 w-24 h-24 md:w-32 md:h-32 object-contain';
                    container.replaceWith(img);
                });
            }

            function renderIcon(placeholderEl, src, teamClass) {
                // If opened from file:/// protocol, Chrome may block CSS mask URLs â€” use <img> fallback
                const isFileProtocol = window.location.protocol === 'file:';
                if (isFileProtocol) {
                    const img = document.createElement('img');
                    img.src = src;
                    img.alt = '';
                    img.className = 'mx-auto mb-3 w-24 h-24 md:w-32 md:h-32 object-contain';
                    // Make it visible on dark background when opened via file://
                    img.style.filter = 'invert(1) brightness(1.2)';
                    placeholderEl.replaceWith(img);
                } else {
                    const maskDiv = document.createElement('div');
                    maskDiv.className = `mx-auto mb-3 w-24 h-24 md:w-32 md:h-32 ${teamClass}`;
                    maskDiv.style.backgroundColor = 'currentColor';
                    maskDiv.style.webkitMaskImage = `url('${src}')`;
                    maskDiv.style.webkitMaskRepeat = 'no-repeat';
                    maskDiv.style.webkitMaskPosition = 'center';
                    maskDiv.style.webkitMaskSize = 'contain';
                    maskDiv.style.maskImage = `url('${src}')`;
                    maskDiv.style.maskRepeat = 'no-repeat';
                    maskDiv.style.maskPosition = 'center';
                    maskDiv.style.maskSize = 'contain';
                    placeholderEl.replaceWith(maskDiv);
                }
            }

            // This function creates a slide for each role and adds it to the page
            console.log('Creating slides for', roles.length, 'roles');
            roles.forEach((role, index) => {
                console.log(`Creating slide ${index + 1}: ${role.name} (${role.team})`);
                const slideEl = document.createElement('div');
                slideEl.className = 'slide';
                // Add data attributes for filtering
                slideEl.dataset.roleName = role.name;
                slideEl.dataset.roleType = newRoles.includes(role.name) ? 'new' : 'standard';
                const iconSrc = roleImageMap[role.name] || 'images/artist.svg';
                // Store role data for regenerating tips
                slideEl.roleData = role;
                // Use a div for ability-text to allow for block elements like <ul>
                slideEl.innerHTML = `
                    <div class="m-auto text-center max-w-6xl slide-content">
                        <div><span class="role-icon-placeholder"></span></div>
                        <h1 class="text-3xl md:text-5xl font-bold mb-3 ${teamColorMap[role.team] || 'villager'}">${role.name}</h1>
                        <p class="text-xl md:text-2xl mb-4 text-gray-400">${role.team}</p>
                        <div class="ability-text text-left">${createAbilityText(role)}</div>
                    </div>
                `;
                slidesContainer.appendChild(slideEl);
                const placeholder = slideEl.querySelector('.role-icon-placeholder');
                renderIcon(placeholder, iconSrc, teamColorMap[role.team] || 'villager');
            });

            console.log('Finished creating slides. Total slides in container:', slidesContainer.children.length);

            // --- Role Filtering Logic ---
            const roleFilter = document.getElementById('role-filter');
            let allSlides = document.querySelectorAll('.slide');
            let visibleSlides = Array.from(allSlides);

            function filterSlides(filterType) {
                // Hide all slides first
                allSlides.forEach(slide => {
                    slide.style.display = 'none';
                });

                // Show slides based on filter
                if (filterType === 'all') {
                    visibleSlides = Array.from(allSlides);
                } else if (filterType === 'new') {
                    visibleSlides = Array.from(allSlides).filter(slide =>
                        slide.dataset.roleType === 'new'
                    );
                } else if (filterType === 'standard') {
                    visibleSlides = Array.from(allSlides).filter(slide =>
                        slide.dataset.roleType === 'standard'
                    );
                }

                // Show filtered slides
                visibleSlides.forEach(slide => {
                    slide.style.display = 'flex';
                });

                // Reset to first slide of filtered set
                currentSlide = 0;
                if (visibleSlides.length > 0) {
                    showSlide(0);
                }
                resetTimer();
            }

            roleFilter.addEventListener('change', (e) => {
                filterSlides(e.target.value);
            });

            // --- Slideshow Logic ---
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const progressBar = document.getElementById('progress-bar');

            let currentSlide = 0;
            let isPlaying = true;
            const slideInterval = 15000; // 15 seconds per slide
            let slideTimer;
            let progressTimer;

            // Function to display a specific slide
            function showSlide(index) {
                // Reset scroll position of the old slide
                if (visibleSlides[currentSlide]) {
                    visibleSlides[currentSlide].scrollTop = 0;
                }
                visibleSlides.forEach((slide, i) => {
                    slide.classList.remove('active');
                    if (i === index) {
                        slide.classList.add('active');
                        // Regenerate random tip for the active slide
                        if (slide.roleData) {
                            const abilityTextEl = slide.querySelector('.ability-text');
                            if (abilityTextEl) {
                                abilityTextEl.innerHTML = createAbilityText(slide.roleData);
                            }
                        }
                    }
                });
            }

            // Function to go to the next slide
            function nextSlide() {
                if (visibleSlides.length === 0) return;
                currentSlide = (currentSlide + 1) % visibleSlides.length;
                showSlide(currentSlide);
                resetTimer();
            }

            // Function to go to the previous slide
            function prevSlide() {
                if (visibleSlides.length === 0) return;
                currentSlide = (currentSlide - 1 + visibleSlides.length) % visibleSlides.length;
                showSlide(currentSlide);
                resetTimer();
            }

            // This function animates the progress bar at the bottom
            function updateProgressBar() {
                let startTime = Date.now();
                clearInterval(progressTimer);

                if(isPlaying) {
                    progressTimer = setInterval(() => {
                        const elapsedTime = Date.now() - startTime;
                        const width = (elapsedTime / slideInterval) * 100;
                        progressBar.style.width = `${width}%`;
                        if (width >= 100) {
                            clearInterval(progressTimer);
                        }
                    }, 100);
                }
            }

            // This function resets the autoplay timer and progress bar
            function resetTimer() {
                clearTimeout(slideTimer);
                clearInterval(progressTimer);
                progressBar.style.transition = 'none'; // Disable transition for instant reset
                progressBar.style.width = '0%';
                progressBar.offsetHeight; // Force browser to repaint, making the reset instant
                progressBar.style.transition = 'width 0.1s linear'; // Re-enable for the next animation

                if (isPlaying) {
                    slideTimer = setTimeout(nextSlide, slideInterval);
                    updateProgressBar();
                }
            }

            // Function to toggle between play and pause states
            function togglePlayPause() {
                isPlaying = !isPlaying;
                if (isPlaying) {
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                    resetTimer();
                } else {
                    pauseIcon.classList.add('hidden');
                    playIcon.classList.remove('hidden');
                    clearTimeout(slideTimer);
                    clearInterval(progressTimer);
                }
            }

            // --- Event Listeners ---
            nextBtn.addEventListener('click', nextSlide);
            prevBtn.addEventListener('click', prevSlide);
            playPauseBtn.addEventListener('click', togglePlayPause);

            // Allow keyboard navigation with arrow keys and spacebar
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowRight') {
                    nextSlide();
                } else if (e.key === 'ArrowLeft') {
                    prevSlide();
                } else if (e.key === ' ') { // Spacebar to play/pause
                    e.preventDefault(); // Prevents the page from scrolling on spacebar press
                    togglePlayPause();
                }
            });

            // Initial setup when the page loads
            showSlide(currentSlide);
            resetTimer();
        });
    </script>
</body>
</html>
